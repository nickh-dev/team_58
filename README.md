# team_58

Функция evaluate
```
def evaluate(number):
    if number >= 5000:
        return float('inf')  # Максимально положительное значение для победы
    else:
        return -abs(5000 - number)  # Приближение к 5000 считается положительным
 ```       
Эта функция оценивает "полезность" текущего состояния игры для ИИ.
Если текущее число number больше или равно 5000, функция возвращает бесконечно большое положительное значение, обозначающее выигрыш ИИ.
В противном случае возвращается отрицательное значение, которое тем меньше, чем дальше число от 5000. Это означает, что чем ближе число к 5000, тем лучше состояние для ИИ.



Функция minimax
```
  def minimax(number, depth, is_maximizing):
      if number >= 5000 or depth == 0:
          return evaluate(number), None
```
Эта часть проверяет базовые условия для остановки рекурсии: если достигнуто число 5000 или исследована максимальная глубина поиска (depth == 0). В этих случаях возвращается оценка текущего состояния.



Максимизирующий ход
```
    if is_maximizing:
        best_score = float('-inf')
        best_move = None
        for multiplier in [2, 3, 4]:
            new_number = number * multiplier
            score, _ = minimax(new_number, depth-1, False)
            if score > best_score:
                best_score = score
                best_move = multiplier
        return best_score, best_move
 ```       
Если is_maximizing истина, мы находимся в ветви ИИ, который стремится максимизировать свою "полезность" игры.
best_score инициализируется как минус бесконечность, чтобы любой первый найденный результат был лучше.
Для каждого возможного множителя (2, 3, 4) рассчитывается новое число (new_number) и для него рекурсивно вызывается minimax с уменьшенной глубиной и инвертированным флагом is_maximizing.
Если новый результат лучше текущего best_score, он обновляется вместе с соответствующим best_move.



Минимизирующий ход
```
    else:
        best_score = float('inf')
        best_move = None
        for multiplier in [2, 3, 4]:
            new_number = number * multiplier
            score, _ = minimax(new_number, depth-1, True)
            if score < best_score:
                best_score = score
                best_move = multiplier
        return best_score, best_move
 ```       
Если is_maximizing ложь, мы предполагаем, что находимся в ветви игрока, который стремится минимизировать "полезность" игры для ИИ.
best_score инициализируется как плюс бесконечность, чтобы любой первый найденный результат мог быть только хуже с точки зрения ИИ.
Аналогично, для каждого множителя рассчитывается new_number и вызывается minimax, но теперь с целью найти ход с наименьшей "полезностью" для ИИ.
best_score и best_move обновляются, если найден ход с меньшей оценкой.


что делает каждая строка кода:
 ``` 
def evaluate(number):
    # Оценивает и возвращает "полезность" текущего состояния игры для ИИ.
    if number >= 5000:
        # Если число достигло или превысило 5000, возвращает максимально большое положительное значение,
        # указывая на выигрышную ситуацию для ИИ.
        return float('inf')
    else:
        # Если число меньше 5000, возвращает отрицательное значение, которое тем меньше,
        # чем дальше число от 5000, что отражает стремление к максимальному приближению к 5000.
        return -abs(5000 - number)

def minimax(number, depth, is_maximizing):
    # Рекурсивно исследует дерево игры, чтобы найти наилучший ход для ИИ.
    if number >= 5000 or depth == 0:
        # Если число достигло 5000 или достигнута максимальная глубина рекурсии,
        # возвращает оценку этого состояния и None как ход, поскольку дальнейшие ходы не рассматриваются.
        return evaluate(number), None

    if is_maximizing:
        # Ветка ИИ, где он пытается максимизировать свою "полезность".
        best_score = float('-inf')  # Инициализация лучшей оценки как минус бесконечность.
        best_move = None  # Лучший ход пока не найден.
        for multiplier in [2, 3, 4]:
            # Перебор всех возможных множителей.
            new_number = number * multiplier  # Вычисление нового числа после хода.
            score, _ = minimax(new_number, depth-1, False)  # Рекурсивный вызов для оценки хода.
            if score > best_score:
                # Если оценка хода лучше текущей лучшей, обновляем лучшую оценку и лучший ход.
                best_score = score
                best_move = multiplier
        return best_score, best_move  # Возврат лучшей оценки и лучшего хода для этой ветки.
    else:
        # Ветка игрока, где предполагается, что он пытается минимизировать "полезность" для ИИ.
        best_score = float('inf')  # Инициализация лучшей оценки как плюс бесконечность.
        best_move = None  # Лучший ход пока не найден.
        for multiplier in [2, 3, 4]:
            # Перебор всех возможных множителей.
            new_number = number * multiplier  # Вычисление нового числа после хода.
            score, _ = minimax(new_number, depth-1, True)  # Рекурсивный вызов для оценки хода.
            if score < best_score:
                # Если оценка хода хуже (для ИИ) текущей лучшей, обновляем лучшую оценку и лучший ход.
                best_score = score
                best_move = multiplier
        return best_score, best_move  # Возврат лучшей оценки и лучшего хода для этой ветки.
 ``` 
